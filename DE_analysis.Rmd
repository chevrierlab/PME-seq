---
title: "DE analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

First we read the results from bcbio into R. The data.frame package provides a variety of tools for working with data frames in R. The `fread()` function is a significantly more efficient and flexible tool for reading in tables than base R, so we'll use it. The annotated_combined.count will be in samples/final/ and then within a folder with the date of the run. Put the name of this folder in folder_name.

```{r read data}
# import data.table library
library(data.table)
# name of folder containing combined count table 
# WILL NEED TO BE UPDATED WITH DATE OF BCBIO RUN
folder_name = "2019-04-29_bcbio_samples"
# make full path of annotated_combined count
count_path = paste0("bcbio_samples/final/", folder_name, "/annotated_combined.counts")
# read table
data <- data.frame(fread(count_path))
rownames(data) = make.names(data$symbol, unique=T)
data$symbol = data$id = NULL
```

We'd next like to filter our data a little. We'll remove genes that don't pass a given threshold of counts per million in at least n samples. We'll use the edgeR package for this. edgeR is one of a few different packages for analysing RNAseq data, including DESeq2 and limma. All have their merits and the exact package of choice is as much personal preference as anything else. We use limma for our actual analysis, but edgeR’s tools for normalizing the data and filtering it are useful. 

```{r fitler genes}
# genes must have at least 50 cpm
cpm_threshold = 50
# in at least 2 samples
cpm_needed = 2

#isolate just 'Ctrl' or 'L' from colnames
experimental.groups = factor(sub('_.*_.*', '', colnames(data)))

# import edgeR library
library(edgeR)
# we need to make our data into a DGE object 
dge <- DGEList(counts = data, group = experimental.groups)
# normalize
dge.norm <- calcNormFactors(dge) 
# calculate filter and save it into a vector
isexpr <- rowSums(cpm(dge.norm) > cpm_threshold) >= cpm_needed
# use the vector to filter the genes
dge.norm.fltd <- dge.norm[isexpr, ]

```

We use limma to do our actual linear modeling. Limma builds an initial model of the system using `lmFit()`. It uses design matrices to indicate how experimental conditions apply to each experimental group. One could imagine quite complex design matrices for quite complex experimental designs, but in a situation where you simply want to compare each group to a control, you can make something quite simple to indicate that each group has a single parameter associated with it. We also use `voom()` to compute appropriate observational weights by transforming count data to log2-counts per million (log2-cpm) with associated weights, and estimating the mean-variance relationship, which prepares the data for linear modeling.

```{r limma first model}
# make our design matrix
design <- model.matrix(~0 + experimental.groups)
# fix names in design matrix
colnames(design) = sub('experimental.groups', '', colnames(design))
# voom to transform
y <- voom(dge.norm.fltd, design, plot=F)
# fit model for each gene
fit <- lmFit(y, design)    
```

Limma uses contrasts to compare between different components of the model. In order to compare each experimental condition to the control, you’ll need to make a contrast matrix that specifies which groups to compare between for each control. The makeContrasts() function takes a vector of strings of the form “a-b”, each specifying the comparison between group a and group b, and produces a contrast matrix.

```{r contrasts}
# make vector of non-control groups (in this case it's just L)
all.conditions <- levels(experimental.groups)
all.conditions <- all.conditions[all.conditions != 'Ctrl']
# make contrast matrix
contrast.matrix <- makeContrasts(contrasts=paste0(all.conditions, '-Ctrl'), levels=design)

# fit contrasts 
fit2 <- contrasts.fit(fit, contrast.matrix)
```

The treat() function computes moderated t-statistics, moderated F-statistic, and log-odds of differential expression with respect to that threshold, by empirical Bayes moderation of the standard errors towards a common value. This gives a p-value for each gene in each contrast, assessing how significantly different the fold change of that gene is from the threshold. Most genes that are significantly different will have fold changes that are much higher than the threshold.

```{r treat}
# our log fold change threshold
lfc_thresh <- log2(1.5) 
# calculat treat
fit.treat <- treat(fit2, lfc_thresh)
```

From here we can use `decideTests()` and `topTreat()` to look at which genes are differentially expressed (DE).

```{r DE genes}
# our adjusted pvalue threshold
padj_thresh = .05

# decide tests outputs a matrix with genes as rows and contrasts as columns
# if a gene is DE up in a given contrast, that position is a 1.
# if it is DE down, that position is a -1.
# if it's neither, the positions is a 0.
decideTests(fit.treat, p.value=padj_thresh)

# if we want more information, we can use topTreat to look at more detail for each gene,
# but only one contrast at a time; coef indicates which contrast to look at.
topTreat(fit.treat, coef=1, p.value=padj_thresh)
```